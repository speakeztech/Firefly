# F* Integration in the Fidelity Framework

## Introduction

This document describes how F*, the proof-oriented programming language developed at Microsoft Research and INRIA, fits into the Fidelity native compilation ecosystem. The integration enables formal verification of F# code with proofs that persist through compilation to native binaries.

F* and F# share more than a naming convention. Both descend from the ML family of languages. F* draws heavily from OCaml in its implementation and semantics, while F# began as "OCaml for .NET" before developing its own identity. This shared heritage creates an opportunity: verified F* code can extract to F#, and with the right infrastructure, that extraction can target native compilation rather than the .NET runtime.

The Fidelity framework includes fsnative (F# Native Compiler Services), a fork of the F# compiler that resolves types to native representations rather than BCL types. When F* extracts to fsnative-compatible F#, the result flows through Firefly's compilation pipeline to produce verified native binaries. The proofs generated by F* do not disappear at the boundary; they travel through MLIR as SMT dialect operations, guiding optimization and validating transformations.

This document covers the architectural vision, the technical alignment between F* and fsnative, and the practical steps toward implementation.

## Background: Proof-Aware Compilation

Two blog posts from SpeakEZ Technologies describe the vision for integrating formal verification into the Fidelity compilation pipeline:

**"Verifying F#"** explores how F# code with verification annotations can generate F* proof obligations automatically. The developer writes standard F# with lightweight annotations expressing preconditions and postconditions:

```fsharp
[<F* Requires("input >= 0 && input <= 100")>]
[<F* Ensures("result >= 0 && result <= 10")>]
let normalizeScore (input: int) : int =
    if input < 0 then 0
    elif input > 100 then 10
    else input / 10
```

The framework translates these annotations to F* verification conditions, invokes the F* verifier, and captures the proof results. Those results then flow into the MLIR compilation pipeline.

**"Proof-Aware Compilation Through Hypergraphs"** describes how proof obligations become first-class elements in Firefly's Program Semantic Graph. Rather than treating proofs as external artifacts that compilation discards, the hypergraph representation preserves them as edges connecting program elements. These proof edges guide optimization: when the compiler knows what properties must hold, it can transform everything else aggressively while preserving correctness.

The approach enables what might seem contradictory: verified code that runs faster than unverified code. Proofs contain information. A bounds-check proof connecting an array to its access patterns tells the compiler exactly which checks can be hoisted, fused, or eliminated. The compiler does not guess; it knows.

SpeakEZ Technologies has a patent pending for this approach: "System and Method for Verification-Preserving Compilation Using Formal Certificate Guided Optimization" (US 63/786,264). The patent covers the novel technique of carrying proof obligations through the compilation pipeline via MLIR's SMT dialect, using them to enable optimizations that would otherwise be unsafe, and validating that transformations preserve proven properties.

## F* Architecture Overview

F* is a dependently-typed functional programming language designed for program verification. Its lineage includes ML, Haskell, and Coq, with implementation primarily in OCaml. The language supports refinement types, effect tracking, and proof automation via SMT solvers.

For readers familiar with OCaml: F* feels like OCaml with dependent types and an embedded proof assistant. The syntax is similar, the module system is similar, and the extraction mechanism produces OCaml code that compiles with standard toolchains.

For readers familiar with .NET: F* is not a .NET language, though it can extract to F#. It runs its own verification engine, then produces code in a target language. Think of it as a source-to-source compiler where the "compilation" step also proves properties about your code.

### The Extraction Model

F* does not directly produce executables. Instead, it extracts verified code to other languages:

- **OCaml**: The primary, well-maintained extraction target
- **F#**: Supported but acknowledged as lagging behind OCaml extraction
- **C**: Via KaRaMeL, for low-level verified code (used in HACL* and Project Everest)
- **WebAssembly**: Also via KaRaMeL

The extraction process uses type-and-effect directed erasure. F* tracks which parts of a program are computationally relevant versus which exist only for verification. Proof-only code erases to unit; computational code translates to the target language.

The intermediate representation is an ML-like syntax that abstracts over the differences between OCaml and F#. Both backends consume this intermediate form and emit concrete code.

### Current State of F# Extraction

The F* documentation is direct about the situation: "F# extraction is plagued by some bugs and lags quite a bit behind OCaml extraction." The repository structure reflects this asymmetry:

- `ulib/ml/` contains the OCaml runtime support (well-maintained)
- `fsharp/base/` contains the F# runtime support (at the repository root, not under ulib)

The `fsharp/base/` directory does contain runtime support files: `Prims.fs`, `FStar_String.fs`, `FStar_Option.fs`, and about 30 other modules. However, these target .NET and have not kept pace with the OCaml equivalents.

This creates an opportunity. The F# extraction path needs work regardless. Rather than updating `fsharp/` to target modern .NET, we would create a new top-level `fsnative/` directory as a peer to `fsharp/`, targeting native compilation. The result would be more valuable for the Fidelity use case and maintains clear separation between .NET and native extraction targets.

## Why fsnative Aligns with F* Semantics

F*'s OCaml extraction produces code with specific characteristics:

- Strings use UTF-8 encoding via the Batteries library
- Option types are value-like algebraic data types
- Integers have explicit width or use arbitrary precision (Zarith)
- Memory management is explicit, not dependent on garbage collection semantics
- Effects are tracked and explicit

These characteristics align poorly with .NET's Base Class Library:

| Concept | F* (OCaml extraction) | .NET BCL |
|---------|----------------------|----------|
| Strings | UTF-8, via BatUTF8 | UTF-16, System.String |
| Options | Value ADT | Reference type, heap-allocated |
| Integers | Explicit width or Z.t | Boxed in generic contexts |
| Memory | No GC assumptions | GC-managed |

The mismatch explains why F# extraction lags. Every primitive type requires adaptation to BCL semantics that differ from what F* expects.

fsnative resolves this mismatch by providing native types that align with F*'s expectations:

| Concept | F* (OCaml extraction) | fsnative |
|---------|----------------------|----------|
| Strings | UTF-8, via BatUTF8 | NativeStr (UTF-8, deterministic lifetime) |
| Options | Value ADT | voption (value type, stack-allocated) |
| Integers | Explicit width | Explicit width, no boxing |
| Memory | No GC assumptions | Arena/stack, explicit lifetimes |

The translation from F* to fsnative is more direct than to .NET F# because fsnative's semantics are closer to what F* already produces for OCaml.

### The OCaml Connection

F* is implemented in OCaml. Its extraction primarily targets OCaml. Its runtime libraries are OCaml code. The language's semantics reflect OCaml's influence: strict evaluation, algebraic data types, pattern matching, module functors.

fsnative, despite its F# syntax, has more in common semantically with OCaml than with .NET F#:

- Both use value semantics for small types
- Both expect explicit memory management (OCaml has a GC, but idiomatic OCaml does not rely on GC semantics for correctness)
- Both treat strings as byte sequences with explicit encoding
- Both support algebraic data types as values, not heap objects

For OCaml developers considering contributing to Fidelity: the type system you would implement in `ulib/fsnative` mirrors what you already know from `ulib/ml`. The syntax is F#, but the semantics are familiar.

## The Integration Architecture

### Extraction Path

The integration adds a new extraction target alongside OCaml and .NET F#:

```
F* Source
    │
    ▼
F* Verifier (proofs generated)
    │
    ▼
ML Intermediate Syntax
    │
    ├──▶ PrintML.fst ──▶ OCaml code
    │
    ├──▶ PrintFS.fst ──▶ .NET F# code (existing, unmaintained)
    │
    └──▶ PrintFSNative.fst ──▶ fsnative code (new)
                                    │
                                    ▼
                              Firefly (FNCS + Alex)
                                    │
                                    ▼
                              MLIR (with SMT dialect)
                                    │
                                    ▼
                              Native Binary
```

The new `PrintFSNative` backend emits F# code that uses Alloy types instead of BCL types. The emitted code compiles with fsnative (FNCS) and flows through Firefly's standard pipeline.

### Runtime Library: fsnative/

F* extracted code requires runtime support for primitive operations. The OCaml extraction uses `ulib/ml/app/`:

```
ulib/ml/app/
├── FStar_String.ml      # String operations via Batteries
├── FStar_Option.ml      # Option type operations
├── FStar_List.ml        # List operations
├── FStar_Bytes.ml       # Byte sequence handling
├── FStar_IO.ml          # I/O operations
├── FStar_Heap.ml        # Heap memory model
├── Prims.ml             # Primitive types and operations
└── ...
```

The existing .NET F# extraction uses `fsharp/base/`:

```
fsharp/base/
├── FStar_String.fs      # String operations (BCL)
├── FStar_Option.fs      # Option type operations
├── FStar_List.fs        # List operations
├── FStar_Bytes.fs       # Byte handling
├── FStar_IO.fs          # I/O operations
├── FStar_Heap.fs        # Heap memory model
├── Prims.fs             # Primitive types
└── ...  (about 30 modules total)
```

The fsnative extraction would add a new top-level directory, peer to `fsharp/`:

```
fsnative/                # NEW: peer to fsharp/, not inside it
├── base/
│   ├── FStar_String.fs      # String operations via Alloy.Text (NativeStr)
│   ├── FStar_Option.fs      # voption operations
│   ├── FStar_List.fs        # List operations via Alloy.Collections
│   ├── FStar_Bytes.fs       # Byte handling via Alloy
│   ├── FStar_IO.fs          # I/O via Alloy.Console, Alloy.IO
│   ├── FStar_Heap.fs        # Memory model mapping to regions
│   ├── Prims.fs             # Primitive types via Alloy
│   └── ...
└── ulibfsnative.fidproj     # Fidelity project file
```

Each file implements the same interface as its OCaml and .NET counterparts but uses Alloy's native types and operations. The parallel structure to `fsharp/` makes the relationship clear: two distinct extraction targets for F# syntax, one targeting .NET, one targeting native.

### Type Mappings

The following table shows how F* types would map to fsnative types:

| F* Type | OCaml (current) | fsnative (proposed) |
|---------|-----------------|---------------------|
| `string` | `string` + BatUTF8 | `NativeStr` |
| `'a option` | `'a option` | `'a voption` |
| `'a list` | `'a list` | `'a list` (Alloy) |
| `'a array` | `'a array` | `NativeArray<'a>` |
| `int` | `Z.t` (arbitrary precision) | `bigint` or explicit width |
| `int32` | `Int32.t` | `int32` |
| `uint8` | `Uint8.t` | `uint8` |
| `bool` | `bool` | `bool` |
| `unit` | `unit` | `unit` |
| `'a * 'b` | `'a * 'b` | `struct ('a * 'b)` |

### Proof Flow Through MLIR

When F* verifies code, it produces proof obligations and discharges them via SMT solving. In the standard extraction model, these proofs validate the F* code but do not travel with the extracted output.

The Fidelity integration changes this. Proof information flows into the Program Semantic Graph as hyperedges connecting program elements. When Alex generates MLIR, these proof edges translate to SMT dialect operations:

```mlir
func.func @normalizeScore(%input: i32) -> i32 {
  // Precondition from F* verification
  %zero = arith.constant 0 : i32
  %hundred = arith.constant 100 : i32
  %ge_zero = smt.bv.sge %input, %zero : !smt.bv<32>
  %le_hundred = smt.bv.sle %input, %hundred : !smt.bv<32>
  %precond = smt.and %ge_zero, %le_hundred : !smt.bool
  smt.assert %precond

  // Function implementation
  // ...

  // Postcondition from F* verification
  %result_ge_zero = smt.bv.sge %result, %zero : !smt.bv<32>
  %result_le_ten = smt.bv.sle %result, %c10 : !smt.bv<32>
  %postcond = smt.and %result_ge_zero, %result_le_ten : !smt.bool
  smt.assert %postcond

  return %result : i32
}
```

These SMT operations serve multiple purposes:

1. **Optimization guidance**: The compiler knows what properties hold, enabling aggressive transformation of everything else
2. **Translation validation**: Optimizations that would violate proven properties are rejected
3. **Selective retention**: In debug builds, assertions can remain as runtime checks; in release builds, they compile away

The proofs do not add runtime overhead in the final binary. They guide compilation, then disappear.

## Fork Strategy

The Fidelity framework would fork FStarLang/FStar rather than hard-fork with a rename. The fork maintains the original name, license (Apache-2.0), and upstream relationship.

### Branch Structure

```
FidelityFramework/FStar (fork of FStarLang/FStar)
├── main                 # Tracks upstream, receives cherry-picks
└── fidelity             # Fidelity-specific development
    ├── fsnative/        # Native F# runtime support (peer to fsharp/)
    ├── src/extraction/  # PrintFSNative backend
    └── ...
```

Development occurs on the `fidelity` branch. General improvements (bug fixes, F# extraction repairs that benefit everyone) are cherry-picked to `main` and submitted as pull requests upstream.

### Why Not Hard Fork

Several considerations favor a soft fork over renaming:

**Academic credibility**: F* has significant reputation in the formal methods community. Microsoft Research, INRIA, and university research groups use and cite F*. A renamed fork would need to establish its own credibility.

**Security community trust**: Projects like HACL* (verified cryptography) and Project Everest (verified TLS) use F*. That provenance matters for security-critical applications.

**Maintenance efficiency**: F* is actively developed. Tracking upstream changes is easier than maintaining a divergent codebase.

**Innovation boundary**: The patent-pending innovation is in Firefly's proof-carrying compilation, not in F* itself. F* is a tool we use; the novel contribution is what happens after F* produces its output.

### Contribution Model

Improvements that benefit the broader F* community flow upstream:

1. Fixes to F# extraction that apply to .NET F# as well as fsnative
2. Bug fixes in the extraction infrastructure
3. Documentation improvements
4. Test coverage additions

Fidelity-specific additions remain in the `fidelity` branch:

1. The `PrintFSNative` backend
2. The `ulib/fsnative` runtime library
3. Integration with Firefly's proof-carrying pipeline
4. Alloy-specific type mappings

## Implementation Phases

### Phase 1: Runtime Library

Create `fsnative/` (as a top-level peer to `fsharp/`) with implementations of F* primitives using Alloy types. This work can proceed independently of extraction changes by manually writing fsnative-compatible code that matches the interfaces expected by F* extracted output. The existing `fsharp/base/` files provide a template for what interfaces need implementation.

Deliverables:
- `Prims.fs`: Primitive types and operations
- `FStar_String.fs`: String operations via Alloy.Text
- `FStar_Option.fs`: voption operations
- `FStar_List.fs`: List operations
- `FStar_Bytes.fs`: Byte handling
- Test suite validating compatibility with F* expectations

### Phase 2: Extraction Backend

Modify or create the extraction backend to emit fsnative-compatible code.

Options under consideration:
- Modify `PrintFS.fst` to accept a configuration flag for fsnative output
- Create a new `PrintFSNative.fst` backend
- Add `--codegen FidelityFSharp` command-line option

Deliverables:
- Extraction backend producing fsnative-compatible F#
- Test suite extracting F* examples and compiling with FNCS

### Phase 3: Proof Integration

Connect F* verification results to Firefly's PSG and MLIR generation.

This phase implements the proof-carrying compilation described in the patent application. F* proofs become hyperedges in the PSG, translate to SMT dialect operations in MLIR, guide optimization, and validate transformations.

Deliverables:
- PSG nodes/edges representing proof obligations
- MLIR generation including SMT dialect operations
- Translation validation using SMT solver
- Proof-guided optimization passes

### Phase 4: Tooling Integration

Integrate F* verification into the Fidelity development experience.

The F* VS Code extension (`fstar-vscode-assistant`) provides interactive verification. This phase would coordinate that extension with FSNAC (FsNativeAutoComplete) to provide a unified experience: F# editing with fsnative type resolution and F* verification in the same editor session.

Deliverables:
- Coordinated VS Code extension configuration
- Unified error reporting (FNCS diagnostics + F* verification results)
- Verification status indicators in the editor

## Technical Considerations

### Integer Representation

F* uses arbitrary-precision integers (`Z.t` via Zarith) by default, with explicit fixed-width types (`FStar.UInt32`, etc.) available. fsnative would need to decide how to handle this:

**Option A**: Implement arbitrary-precision integers in Alloy, use them as the default `int` type.

**Option B**: Require explicit width annotations in F* code targeting fsnative, map `int` to a reasonable default (e.g., `int64`).

**Option C**: Provide both, let developers choose per-project.

The choice affects verification. Arbitrary-precision integers simplify proofs (no overflow concerns) but complicate native code generation. Fixed-width integers match hardware but require overflow reasoning.

### Effect System Mapping

F* tracks effects: `Tot` (total, pure), `ML` (may diverge, may have effects), `ST` (stateful), `IO` (input/output). These effects carry verification information about what a function may do.

fsnative has its own effect tracking through coeffects. The extraction would need to map F* effects to fsnative's representation:

| F* Effect | Meaning | fsnative Mapping |
|-----------|---------|------------------|
| `Tot` | Total, pure | Pure function |
| `ML` | May diverge | General function |
| `ST` | Stateful | Memory region access |
| `IO` | I/O effects | Platform binding access |

The mapping preserves information needed for verification while fitting fsnative's native compilation model.

### Memory Model

F* has sophisticated memory models including HyperStack for reasoning about stack and heap allocation. fsnative has memory regions (Stack, Heap, Arena, Peripheral, Flash).

A complete integration would map F* memory reasoning to fsnative regions:

| F* Concept | fsnative Equivalent |
|------------|---------------------|
| Stack frames | Stack region |
| Heap references | Heap region |
| Eternal references | Arena region |
| Memory-mapped I/O | Peripheral region |

This mapping enables F* proofs about memory safety to carry through to native code where they guide allocation decisions and verify access patterns.

## Relationship to Other Fidelity Components

| Component | Role in F* Integration |
|-----------|----------------------|
| **fsnative (FNCS)** | Compiles extracted F# with native type resolution |
| **Firefly** | Orchestrates compilation, generates MLIR with proof information |
| **Alloy** | Provides runtime types that F* extraction targets |
| **Alex** | Generates MLIR including SMT dialect operations |
| **BAREWire** | Binary encoding; F* could verify protocol implementations |
| **JellyJar** | Solution coherence; could verify contracts across projects |

## For Contributors

### OCaml Developers

If you work in OCaml and are curious about Fidelity: the `fsnative/` implementation is essentially porting OCaml code to F# syntax with Alloy types. The semantics are familiar. Pattern matching, algebraic data types, explicit effects, value semantics for small types. The main adjustment is syntax: `let` bindings look slightly different, modules use different keywords, but the concepts translate directly.

The F* extraction infrastructure is OCaml code. Modifications to `PrintFS.fst` or creation of `PrintFSNative.fst` happen in F* (which reads much like OCaml with dependent types). If you can write OCaml, you can contribute here.

### F# Developers

If you work in F# on .NET: fsnative is still F#. The syntax is identical. What changes is what types mean. When you write `string`, fsnative resolves it to `NativeStr` rather than `System.String`. When you write `Some x`, you get a value-type option rather than a heap-allocated reference.

The F* integration adds verification. You write F# with annotations, the framework generates proofs, and those proofs guide compilation. You do not need to learn F* to benefit from verification; the tooling handles the translation.

### Verification Researchers

If you work in formal methods: the novel contribution here is proof-carrying compilation through MLIR. F* generates proofs; Firefly preserves them through code generation via the SMT dialect. This enables verification-aware optimization: transformations that are safe given proven properties but would be unsafe in general.

The hypergraph representation treats proofs as first-class edges connecting program elements. This structure enables composition (proofs from different sources combine), deduplication (shared proofs across call sites), and incremental verification (local changes re-verify locally).

## Current Status

This integration is in the design phase. The architecture described here represents our current thinking about how F* and Fidelity should work together.

Implemented:
- Fidelity compilation pipeline (Firefly, FNCS, Alex)
- Alloy native standard library
- PSG hypergraph representation

In progress:
- fsnative type resolution refinements
- MLIR SMT dialect integration

Planned:
- `ulib/fsnative` runtime library
- F* extraction backend for fsnative
- Proof-carrying compilation implementation
- Tooling integration

## References

### Fidelity Framework

- [Firefly](https://github.com/FidelityFramework/Firefly): AOT compiler for F#
- [Alloy](https://github.com/FidelityFramework/Alloy): Native standard library
- [fsnative](https://github.com/FidelityFramework/fsnative): F# Native Compiler Services
- [fsnative-spec](https://github.com/FidelityFramework/fsnative-spec): Language specification

### F* Resources

- [F* GitHub](https://github.com/FStarLang/FStar): Main repository
- [F* Tutorial](https://fstar-lang.org/tutorial/): Introduction to F*
- [Proof-oriented Programming in F*](https://fstar-lang.org/tutorial/book/): The F* book
- [F* Wiki: Executing F* Code](https://github.com/FStarLang/FStar/wiki/Executing-F*-code): Extraction documentation

### Related Projects

- [KaRaMeL](https://github.com/FStarLang/karamel): F* to C extraction
- [HACL*](https://github.com/hacl-star/hacl-star): Verified cryptographic library
- [Project Everest](https://project-everest.github.io/): Verified secure communication

### Academic References

- Fehr, M., et al. (2025). "First-Class Verification Dialects for MLIR." PLDI 2025. The foundation for SMT dialect integration.

### Patent

- US 63/786,264: "System and Method for Verification-Preserving Compilation Using Formal Certificate Guided Optimization" (pending)
