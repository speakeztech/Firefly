# Hardware Showcase Roadmap

This document outlines the vision for demonstrating F# compiled through the Fidelity framework to hardware targets, covering two fundamentally different deployment models:

1. **QuantumCredential (STM32L5)** - True bare-metal unikernel, no OS
2. **Keystation (Libre Sweet Potato)** - Native Linux application with FidelityUI

These represent different points on the Fidelity spectrum, both demonstrating F# compiled to efficient native code, but with different runtime environments.

## Executive Summary

### Two Deployment Models

| Aspect | QuantumCredential | Keystation |
|--------|-------------------|------------|
| **Hardware** | STM32L5 Nucleo (Cortex-M33) | Libre Sweet Potato (Cortex-A53) |
| **Model** | **Unikernel** - bare metal | **Linux App** - userspace process |
| **OS** | None | Minimal embedded Linux |
| **Kernel** | None | Linux kernel (drivers, USB, display) |
| **Startup** | Vector table, direct boot | Linux init, process launch |
| **I/O** | Direct register access | Linux syscalls / device files |
| **Display** | None (USB HID only) | LVGL via Linux framebuffer |
| **Touch** | N/A | Linux evdev / hid-multitouch |
| **USB** | Direct USB peripheral driver | Linux USB stack |

### Why Two Models?

**QuantumCredential** requires bare-metal for security:
- Deterministic timing (side-channel resistance)
- No OS attack surface
- TrustZone isolation
- Complete control over all code paths

**Keystation** requires Linux for practicality:
- WaveShare touchscreen needs `hid-multitouch` kernel module
- HDMI output needs display drivers
- USB enumeration is complex without an OS
- 2GB RAM makes Linux overhead negligible

Both still benefit from Fidelity's core value proposition: F# compiled to native code with deterministic memory management. The difference is what sits beneath the application.

---

## Target 1: QuantumCredential - True Unikernel

### Hardware: STM32L5 (Cortex-M33)

The STM32L5 is a security-focused microcontroller:

| Specification | Value |
|---------------|-------|
| **Core** | ARM Cortex-M33 @ 110 MHz |
| **Architecture** | ARMv8-M Mainline |
| **Flash** | 512 KB |
| **SRAM** | 256 KB |
| **Security** | TrustZone, hardware crypto (AES, PKA, RNG), tamper detection |
| **Certification** | PSA Certified Level 2 |

**Key Security Features:**
- [TrustZone isolation](https://www.st.com/resource/en/application_note/an5347-introduction-to-arm-trustzone-features-on-stm32l5-stm32u5-and-stm32u3-mcus-stmicroelectronics.pdf) separates secure and non-secure code
- Hardware crypto acceleration (AES 128/256, RSA, ECC)
- Secure key storage and OTP memory
- Active tamper detection with automatic secret erasure

### What "Unikernel" Means

A true unikernel has:
- **No operating system** - your code IS the entire software stack
- **No kernel** - no scheduler, no virtual memory, no process isolation
- **Direct hardware access** - registers at physical addresses
- **Single address space** - no user/kernel boundary
- **Boot to main()** - vector table points directly to your code

```
┌─────────────────────────────────────────────────────────────┐
│ QuantumCredential Unikernel                                 │
├─────────────────────────────────────────────────────────────┤
│ Your F# Application (compiled via Fidelity)                │
│   - main() entry point                                      │
│   - Alloy library (native F# stdlib)                       │
│   - Application logic                                       │
├─────────────────────────────────────────────────────────────┤
│ HAL Bindings (generated by Farscape)                       │
│   - GPIO, UART, USB peripheral drivers                     │
│   - Direct register manipulation                            │
│   - Interrupt handlers                                      │
├─────────────────────────────────────────────────────────────┤
│ Startup Code (generated by Firefly)                        │
│   - Vector table                                            │
│   - Stack initialization                                    │
│   - BSS zeroing, data copying                              │
├─────────────────────────────────────────────────────────────┤
│ STM32L5 Hardware                                           │
│   - Flash at 0x08000000                                    │
│   - SRAM at 0x20000000                                     │
│   - Peripherals memory-mapped                              │
└─────────────────────────────────────────────────────────────┘
```

### Compilation Pipeline for Unikernel

```
F# Source + Alloy + HAL Bindings
        ↓ FCS
    Typed AST
        ↓ PSG Builder
    Program Semantic Graph
        ↓ Nanopasses
    Enriched PSG
        ↓ Alex (ARM_Cortex_M33 bindings)
    MLIR (with direct register access)
        ↓ LLVM (thumbv8m.main-none-eabi)
    Object files
        ↓ Linker (with memory layout script)
    ELF binary
        ↓ probe-rs / OpenOCD
    Flashed to STM32L5
```

### LLVM Targeting for Cortex-M33

```bash
# LLVM/Clang compilation flags for STM32L5 unikernel
clang \
    --target=thumbv8m.main-none-eabi \
    -mcpu=cortex-m33 \
    -mfloat-abi=hard \
    -mfpu=fpv5-sp-d16 \
    -mthumb \
    -nostdlib \
    -ffreestanding \
    -ffunction-sections \
    -fdata-sections \
    -O2 \
    source.c
```

**Key flags:**
- `thumbv8m.main-none-eabi`: ARMv8-M, **no OS**, EABI calling convention
- `-nostdlib`: No standard library - Alloy provides everything
- `-ffreestanding`: No hosted environment assumptions

### Linker Script for STM32L5

```ld
/* STM32L552 Memory Layout - Unikernel */
MEMORY
{
    FLASH (rx)  : ORIGIN = 0x08000000, LENGTH = 512K
    SRAM1 (rwx) : ORIGIN = 0x20000000, LENGTH = 192K
    SRAM2 (rwx) : ORIGIN = 0x20030000, LENGTH = 64K  /* TrustZone secure */
}

ENTRY(Reset_Handler)

SECTIONS
{
    .vectors : {
        KEEP(*(.vectors))
    } > FLASH

    .text : {
        *(.text*)
        *(.rodata*)
    } > FLASH

    .data : {
        _sdata = .;
        *(.data*)
        _edata = .;
    } > SRAM1 AT > FLASH

    .bss : {
        _sbss = .;
        *(.bss*)
        *(COMMON)
        _ebss = .;
    } > SRAM1

    _stack_top = ORIGIN(SRAM1) + LENGTH(SRAM1);
}
```

### Alex Bindings for Unikernel

For the unikernel, Alex generates **direct register access**:

```fsharp
// What you write in F#
GPIO.writeHigh GPIOA Pin5

// What Alex generates (MLIR)
func.func @gpio_write_high(%port: i32, %pin: i32) {
    // BSRR register offset is 0x18 from GPIO base
    %bsrr_offset = arith.constant 0x18 : i32
    %addr = arith.addi %port, %bsrr_offset : i32
    %ptr = llvm.inttoptr %addr : i32 to !llvm.ptr<i32>
    %one = arith.constant 1 : i32
    %mask = arith.shli %one, %pin : i32
    llvm.store %mask, %ptr {volatile} : !llvm.ptr<i32>
    return
}
```

No syscalls. No kernel. Just direct memory-mapped I/O.

### Memory Model: Stack-Only

The STM32L5 with 256KB SRAM uses strict stack allocation:

| Region | Size | Usage |
|--------|------|-------|
| Flash | 512 KB | Code, const data, vector table |
| SRAM1 | 192 KB | Stack (16KB), static data, buffers |
| SRAM2 | 64 KB | Secure data (TrustZone protected) |

```fsharp
// BAREWire schema for peripheral registers - zero allocation
[<BAREStruct>]
type GPIO_TypeDef = {
    [<BAREField(0, Offset = 0x00)>] MODER: uint32
    [<BAREField(1, Offset = 0x04)>] OTYPER: uint32
    [<BAREField(2, Offset = 0x08)>] OSPEEDR: uint32
    [<BAREField(3, Offset = 0x0C)>] PUPDR: uint32
    [<BAREField(4, Offset = 0x10)>] IDR: uint32
    [<BAREField(5, Offset = 0x14)>] ODR: uint32
    [<BAREField(6, Offset = 0x18)>] BSRR: uint32
    [<BAREField(7, Offset = 0x1C)>] LCKR: uint32
    [<BAREField(8, Offset = 0x20)>] AFR: uint32 array
}

// Direct memory-mapped access
let GPIOA : nativeptr<GPIO_TypeDef> = NativePtr.ofNativeInt 0x42020000n
```

### USB on Unikernel

For QuantumCredential's USB HID, the unikernel includes a USB device stack:

```fsharp
// USB peripheral driver - direct register access, no OS
module USB =
    // USB OTG registers at 0x4000D400
    let private USB_BASE = 0x4000D400n

    [<DllImport("__fidelity_hal", EntryPoint="usb_init")>]
    extern void init()

    [<DllImport("__fidelity_hal", EntryPoint="usb_send_report")>]
    extern int sendReport(nativeptr<byte> data, int len)

    [<DllImport("__fidelity_hal", EntryPoint="usb_receive_report")>]
    extern int receiveReport(nativeptr<byte> buffer, int maxLen)
```

This is statically linked - the USB stack becomes part of the unikernel binary.

### Flashing and Debugging

```bash
# Flash via probe-rs
probe-rs download --chip STM32L552ZETx ./target/quantum_credential.elf

# Debug output via RTT (Real-Time Transfer)
probe-rs rtt --chip STM32L552ZETx
```

---

## Target 2: Keystation - Linux Native Application

### Hardware: Libre Sweet Potato (Cortex-A53)

The [Sweet Potato (AML-S905X-CC-V2)](https://libre.computer/products/aml-s905x-cc-v2/):

| Specification | Value |
|---------------|-------|
| **SoC** | Amlogic S905X |
| **Core** | Quad-core ARM Cortex-A53 @ 1.5 GHz |
| **Architecture** | ARMv8-A (AArch64) |
| **RAM** | 2 GB DDR3 |
| **GPU** | Mali-450 MP3 |
| **Video** | 4K HDMI 2.0 |

### Why Linux, Not Unikernel

The Keystation needs:
- **WaveShare touchscreen** - requires `hid-multitouch` kernel module
- **HDMI output** - requires display drivers (fbdev or DRM)
- **USB enumeration** - the S905X USB controller needs a full USB stack

A unikernel would require implementing:
- USB host controller driver for DWC2/DWC3
- Full USB stack (enumeration, HID parsing)
- Display controller driver
- Touch protocol parsing

This is months of work. Linux provides all of this.

### What "Linux Native Application" Means

```
┌─────────────────────────────────────────────────────────────┐
│ Keystation Application (Fidelity-compiled F#)              │
│   - FidelityUI with LVGL                                   │
│   - Application logic                                       │
│   - Alloy library                                          │
├─────────────────────────────────────────────────────────────┤
│ Linux Interfaces                                            │
│   - /dev/fb0 (framebuffer)                                 │
│   - /dev/input/event* (touch via evdev)                    │
│   - /dev/hidraw* (USB HID for QuantumCredential)           │
│   - Standard syscalls (open, read, write, mmap, ioctl)     │
├─────────────────────────────────────────────────────────────┤
│ Minimal Linux Kernel                                        │
│   - fbdev / DRM display driver                             │
│   - hid-multitouch for WaveShare touch                     │
│   - USB drivers (dwc2/dwc3)                                │
│   - Basic filesystems                                       │
├─────────────────────────────────────────────────────────────┤
│ Sweet Potato Hardware                                       │
└─────────────────────────────────────────────────────────────┘
```

The F# application is a **userspace process** running on Linux. It still has:
- No garbage collector (Fidelity's deterministic memory)
- Native compilation (not interpreted)
- Direct control over its memory layout

But it uses Linux for hardware abstraction.

### Compilation Pipeline for Linux App

```
F# Source + Alloy + Linux Bindings
        ↓ FCS
    Typed AST
        ↓ PSG Builder
    Program Semantic Graph
        ↓ Nanopasses
    Enriched PSG
        ↓ Alex (Linux_AArch64 bindings)
    MLIR (with Linux syscalls)
        ↓ LLVM (aarch64-unknown-linux-gnu)
    ELF executable
        ↓ Copy to SD card / deploy
    Runs as Linux process
```

### LLVM Targeting for Linux AArch64

```bash
# LLVM/Clang compilation flags for Linux application
clang \
    --target=aarch64-unknown-linux-gnu \
    -mcpu=cortex-a53 \
    -ffunction-sections \
    -fdata-sections \
    -O2 \
    source.c
```

**Key difference from unikernel:**
- `aarch64-unknown-linux-gnu`: AArch64 **with Linux** userspace
- No `-nostdlib` or `-ffreestanding` - we use Linux syscalls

### Alex Bindings for Linux

For the Linux app, Alex generates **syscalls**, not register access:

```fsharp
// What you write in F#
Console.writeLine "Hello from Keystation"

// What Alex generates (MLIR) - Linux syscall
func.func @write_stdout(%ptr: !llvm.ptr, %len: i64) -> i64 {
    %fd = arith.constant 1 : i64           // stdout
    %syscall_nr = arith.constant 64 : i64  // write syscall on AArch64
    %result = llvm.inline_asm has_side_effects
        "svc #0",
        "={x0},{x8},{x0},{x1},{x2}"
        %syscall_nr, %fd, %ptr, %len : (i64, i64, !llvm.ptr, i64) -> i64
    return %result : i64
}
```

### GPIO on Linux

For GPIO access, the application uses Linux sysfs or gpiod:

```fsharp
// GPIO via Linux sysfs - NOT direct register access
module LinuxGPIO =
    let export (pin: int) =
        File.WriteAllText("/sys/class/gpio/export", string pin)

    let setDirection (pin: int) (dir: Direction) =
        let path = sprintf "/sys/class/gpio/gpio%d/direction" pin
        File.WriteAllText(path, match dir with In -> "in" | Out -> "out")

    let write (pin: int) (value: bool) =
        let path = sprintf "/sys/class/gpio/gpio%d/value" pin
        File.WriteAllText(path, if value then "1" else "0")

// Or using libgpiod bindings (generated by Farscape)
module GpioD =
    [<DllImport("libgpiod.so.2")>]
    extern nativeptr<GpioChip> gpiod_chip_open(string path)

    [<DllImport("libgpiod.so.2")>]
    extern int gpiod_line_set_value(nativeptr<GpioLine> line, int value)
```

### Display via Linux Framebuffer

LVGL talks to `/dev/fb0`:

```c
// LVGL framebuffer backend (linked into application)
#define LV_USE_LINUX_FBDEV 1

// Initialization
lv_display_t *disp = lv_linux_fbdev_create();
lv_linux_fbdev_set_file(disp, "/dev/fb0");
```

### Touch via Linux evdev

The WaveShare touch uses Linux's input subsystem:

```c
// LVGL evdev backend for touch
#define LV_USE_EVDEV 1

// Touch device discovered via /dev/input/event*
lv_indev_t *touch = lv_evdev_create(LV_INDEV_TYPE_POINTER, "/dev/input/event0");
lv_indev_set_display(touch, disp);
```

The kernel's `hid-multitouch` module handles:
- USB enumeration of WaveShare device
- HID report parsing
- Touch event generation
- Multi-touch coordinate processing

Your application just reads from evdev.

### Memory Model: Stack + Arena

With 2GB RAM, more flexibility is available:

| Region | Size | Usage |
|--------|------|-------|
| Code | ~2-4 MB | Application, Alloy, LVGL |
| Stack | 1 MB | Call stacks, local buffers |
| Arenas | Variable | Request-scoped allocations |
| Static | ~1 MB | Configuration, lookup tables |
| Framebuffer | ~2 MB | Display memory (mmap'd) |

```fsharp
// Arena allocation for request handling
module Arena =
    let withArena (size: int<bytes>) (f: Arena -> 'T) : 'T =
        let arena = Arena.create size
        try f arena
        finally Arena.release arena

let handleUIEvent (event: TouchEvent) =
    Arena.withArena 64<KB> (fun arena ->
        let response = processEvent event arena
        updateDisplay response
    )
```

### Boot Configuration

The Sweet Potato boots via U-Boot to a minimal Linux:

```bash
# /etc/init.d/keystation or systemd service

# Disable console blanking
echo 0 > /sys/class/graphics/fb0/blank

# Load touch driver if needed
modprobe hid-multitouch

# Launch application
exec /opt/keystation/keystation
```

---

## Side-by-Side Comparison

### Extern Primitives

| Operation | Unikernel (STM32L5) | Linux App (Sweet Potato) |
|-----------|---------------------|--------------------------|
| GPIO Write | Direct BSRR register write | sysfs write or libgpiod |
| Console Out | UART register manipulation | write() syscall to stdout |
| USB Send | USB peripheral registers | write() to /dev/hidraw* |
| Display | N/A | mmap() framebuffer, LVGL |
| Touch Input | N/A | read() from /dev/input/event* |
| Sleep | Timer peripheral + WFI | nanosleep() syscall |

### Farscape Bindings

For **unikernel** targets, Farscape generates bindings to CMSIS HAL:
```fsharp
// Direct HAL bindings - compiled into binary
[<DllImport("__fidelity_hal", EntryPoint="HAL_GPIO_WritePin")>]
extern void writePin(nativeptr<GPIO_TypeDef> port, uint16 pin, GPIO_PinState state)
```

For **Linux** targets, Farscape generates bindings to Linux libraries:
```fsharp
// Linux library bindings - dynamically linked
[<DllImport("libgpiod.so.2")>]
extern int gpiod_line_set_value(nativeptr<GpioLine> line, int value)

[<DllImport("libc.so.6")>]
extern int64 write(int fd, nativeptr<byte> buf, uint64 count)
```

### Alex Platform Bindings

```fsharp
// ExternDispatch routes based on target
module ExternDispatch =
    let dispatch (prim: ExternPrimitive) =
        match currentTarget with
        | ARM_Cortex_M33 ->
            // Generate direct register access
            ARM_M33_Bindings.generate prim
        | Linux_AArch64 ->
            // Generate Linux syscalls
            Linux_AArch64_Bindings.generate prim
        | Linux_x86_64 ->
            // Current desktop target
            Linux_x86_64_Bindings.generate prim
```

---

## The Fidelity Value Proposition

Both targets demonstrate Fidelity's core value:

**F# code with deterministic memory, compiled to native performance.**

| Benefit | Unikernel | Linux App |
|---------|-----------|-----------|
| No GC pauses | ✓ | ✓ |
| Predictable latency | ✓ | ✓ (userspace) |
| Type safety | ✓ | ✓ |
| Native performance | ✓ | ✓ |
| Small binary | ✓ (~100KB) | ✓ (~5MB with LVGL) |

The difference is:
- **Unikernel**: Complete control, security, bare metal
- **Linux App**: Leverage OS for complex hardware, faster development

---

## Development Workflow

### QuantumCredential (Unikernel)

```bash
# Build
firefly compile QuantumCredential.fidproj --target thumbv8m.main-none-eabi

# Flash
probe-rs download --chip STM32L552ZETx ./target/quantum_credential.elf

# Debug output
probe-rs rtt --chip STM32L552ZETx
```

### Keystation (Linux App)

```bash
# Build
firefly compile Keystation.fidproj --target aarch64-unknown-linux-gnu

# Deploy (copy to SD card or SCP)
scp ./target/keystation root@keystation.local:/opt/keystation/

# Run (SSH or auto-start)
ssh root@keystation.local /opt/keystation/keystation
```

### Demo Day Setup

```
┌─────────────────┐       USB HID        ┌─────────────────┐
│  Host Machine   │◄────────────────────►│ STM32L5 Nucleo  │
│  (Demo Client)  │                      │ QuantumCred     │
└─────────────────┘                      │ (Unikernel)     │
                                         └─────────────────┘
                                                ▲
                                                │ SWD Debug
                                                ▼
                                         ┌─────────────────┐
                                         │ ST-Link Probe   │
                                         └─────────────────┘

┌─────────────────┐       USB HID        ┌─────────────────┐
│  Sweet Potato   │◄────────────────────►│ STM32L5 Nucleo  │
│  Keystation     │                      │ QuantumCred     │
│  (Linux App)    │                      └─────────────────┘
│  + WaveShare    │
│    Display      │
└─────────────────┘
```

---

## Roadmap Phases

### Phase 1: Foundation (Current)
- [x] PSG captures full semantic graph from FCS
- [x] Alex generates MLIR via Zipper traversal
- [x] ExternDispatch routes primitives to platform bindings
- [x] Sample 01 compiles and runs on Linux x86_64

### Phase 2: Cross-Compilation Infrastructure
- [ ] Add ARM target triple support to compilation orchestrator
- [ ] Linux_AArch64 bindings (syscalls for Sweet Potato)
- [ ] ARM_Cortex_M33 bindings (register access for STM32L5)
- [ ] Verify LLVM cross-compilation

### Phase 3: Unikernel Support (QuantumCredential)
- [ ] Linker script generation for Cortex-M memory layout
- [ ] Startup code generation (vector table, stack init)
- [ ] Farscape CMSIS HAL bindings
- [ ] USB device stack integration
- [ ] TrustZone secure world setup

### Phase 4: Linux App Support (Keystation)
- [ ] Farscape libgpiod bindings
- [ ] FidelityUI + LVGL integration
- [ ] Linux framebuffer backend
- [ ] Linux evdev touch backend
- [ ] Minimal Linux image for Sweet Potato

### Phase 5: QuantumCredential PoC
- [ ] Hardware crypto bindings (AES, PKA)
- [ ] USB HID credential protocol
- [ ] Secure key storage
- [ ] Demo integration

### Phase 6: Keystation PoC
- [ ] FidelityUI application
- [ ] Touch-optimized interface
- [ ] USB HID client for QuantumCredential
- [ ] Demo integration with WaveShare display

---

## References

### SpeakEZ Blog Posts
- "F# Goes Metal: Fidelity's Hardware/Software Co-Design Revolution"
- "The Farscape Bridge"
- "Binding F# to C++ in Farscape"
- "Building User Interfaces with the Fidelity Framework"
- "Memory Management by Choice"
- "Getting the Signal with BAREWire"

### External Resources
- [CMSIS Documentation](https://arm-software.github.io/CMSIS_5/General/html/index.html)
- [probe-rs](https://probe.rs/) - Embedded debugging
- [STM32L5 TrustZone Guide](https://www.st.com/resource/en/application_note/an5347-introduction-to-arm-trustzone-features-on-stm32l5-stm32u5-and-stm32u3-mcus-stmicroelectronics.pdf)
- [LVGL Linux Framebuffer Driver](https://docs.lvgl.io/master/details/integration/embedded_linux/drivers/fbdev.html)
- [LVGL Evdev Touch Driver](https://docs.lvgl.io/9.2/integration/driver/touchpad/evdev.html)
- [Libre Computer Sweet Potato](https://libre.computer/products/aml-s905x-cc-v2/)
- [WaveShare 7" Display](https://www.waveshare.com/wiki/7inch_HDMI_LCD_(C))

### Related Firefly Documentation
- `docs/Architecture_Canonical.md` - Layer separation principles
- `docs/Alex_Architecture_Overview.md` - Alex/Zipper/Bindings architecture
- `docs/Demo_UI_Stretch_Goal.md` - FidelityUI demo plans
