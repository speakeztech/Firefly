# Memory Interlock Requirements: fsnative, Farscape, and BAREWire

> **Related Document**: See [Quotation_Based_Memory_Architecture.md](./Quotation_Based_Memory_Architecture.md) for the unified
> quotation + active pattern infrastructure that builds on these interlocking dependencies.

## Executive Summary

This document defines the critical dependency chain between fsnative, Farscape, and BAREWire for memory mapping in the Fidelity framework. **These components must advance in lockstep** because each provides types that the next consumes.

The chain is:

```
FSharp.UMX ──absorption──▶ fsnative ──provides types to──▶ Farscape ──uses──▶ BAREWire
```

Failure to maintain this interlock results in type mismatches, missing abstractions, and ultimately blocked progress on hardware targets like the January STM32L5 demo.

## The Dependency Chain

### Layer 1: FSharp.UMX → fsnative (Absorption)

**What UMX Provides:**
- `[<MeasureAnnotatedAbbreviation>]` attribute for non-numeric types
- The `%` operator for tagging/untagging values
- Pattern for extending F#'s measure system beyond numerics

**What fsnative Absorbs:**
- Non-numeric types can carry measure parameters
- Memory regions become first-class measures: `[<Measure>] type peripheral`
- Access kinds become first-class measures: `[<Measure>] type readOnly`

**Critical Types Enabled:**

```fsharp
// After UMX absorption into fsnative
[<MeasureAnnotatedAbbreviation>]
type NativePtr<'T, [<Measure>] 'region, [<Measure>] 'access> = nativeptr<'T>

// Memory region measures
[<Measure>] type peripheral    // Volatile, memory-mapped I/O
[<Measure>] type sram          // Normal RAM
[<Measure>] type flash         // Read-only storage
[<Measure>] type stack         // Thread-local

// Access kind measures
[<Measure>] type readOnly      // CMSIS __I
[<Measure>] type writeOnly     // CMSIS __O
[<Measure>] type readWrite     // CMSIS __IO
```

**Interlock Requirement:** UMX patterns must be absorbed into fsnative BEFORE Farscape can generate type-safe peripheral bindings. Otherwise, Farscape can only generate untyped pointers without region/access safety.

### Layer 2: fsnative → Farscape (Type Provision)

**What fsnative Provides to Farscape:**
- `NativePtr<'T, 'region, 'access>` for typed peripheral access
- Memory region measures for classifying hardware memory
- Access kind measures for enforcing read/write constraints
- Compile-time errors (FS8001-FS8003) for violations

**What Farscape Generates:**

```fsharp
// Generated by Farscape from CMSIS headers
[<PeripheralDescriptor("GPIOA", 0x48000000UL)>]
type GPIO_TypeDef = {
    [<Register("MODER", 0x00u, "rw")>]
    MODER: NativePtr<uint32, peripheral, readWrite>

    [<Register("IDR", 0x10u, "r")>]
    IDR: NativePtr<uint32, peripheral, readOnly>

    [<Register("ODR", 0x14u, "rw")>]
    ODR: NativePtr<uint32, peripheral, readWrite>

    [<Register("BSRR", 0x18u, "w")>]
    BSRR: NativePtr<uint32, peripheral, writeOnly>
}
```

**Interlock Requirement:** fsnative must provide `NativePtr<'T, 'region, 'access>` and the measure types BEFORE Farscape can generate proper bindings. Without these types, Farscape falls back to unsafe `nativeint` or BCL-dependent types.

### Layer 3: Farscape → BAREWire (Memory Descriptors)

**What Farscape Needs from BAREWire:**

The BAREWire hardware memory descriptor types:

```fsharp
type PeripheralDescriptor = {
    Name: string                          // "GPIO"
    Instances: Map<string, unativeint>    // GPIOA → 0x48000000
    Layout: PeripheralLayout
    MemoryRegion: MemoryRegionKind
}

and FieldDescriptor = {
    Name: string                          // "ODR", "BSRR"
    Offset: int                           // Byte offset from base
    Type: RegisterType
    Access: AccessKind                    // ReadOnly | WriteOnly | ReadWrite
    BitFields: BitFieldDescriptor list option
}

and AccessKind =
    | ReadOnly   // __I - reads hardware state, writes are UB
    | WriteOnly  // __O - writes trigger action, reads undefined
    | ReadWrite  // __IO - normal volatile access

and MemoryRegionKind =
    | Flash           // Read-only at runtime
    | SRAM            // Normal RAM
    | Peripheral      // Memory-mapped I/O, volatile
    | SystemControl   // ARM system peripherals
```

**Current Status:** These types **DO NOT EXIST** in BAREWire as of December 2024. The BAREWire memory notes explicitly state "Status: NOT YET IMPLEMENTED".

**What Farscape Outputs Using BAREWire:**

Farscape parses C/C++ headers and populates BAREWire descriptors:

```
CMSIS Header (.h)
    ↓ Farscape parses (clang JSON AST + macros)
    ↓
Farscape Output:
    ├── Types.fs (F# structs using fsnative types)
    ├── Bindings.fs (extern declarations)
    └── Descriptors (BAREWire memory catalog) ← BLOCKED
```

**Interlock Requirement:** BAREWire must provide `PeripheralDescriptor`, `FieldDescriptor`, `AccessKind`, and `MemoryRegionKind` types BEFORE Farscape can generate the complete hardware memory catalog.

## Current Gap Analysis

| Component | Status | Blocking Issue |
|-----------|--------|----------------|
| **FSharp.UMX** | Available | None - ready for absorption |
| **fsnative** | In development | UMX absorption not complete |
| **Farscape parser** | Non-functional | CppParser hardcoded to cJSON.h only |
| **Farscape type gen** | Works for P/Invoke | Needs fsnative types for Fidelity output |
| **BAREWire descriptors** | **NOT IMPLEMENTED** | Missing `PeripheralDescriptor` family |

### Critical Path for January Demo

The January STM32L5 demo requires:

1. **BAREWire**: Add `PeripheralDescriptor`, `FieldDescriptor`, `AccessKind`, `MemoryRegionKind`
2. **fsnative**: Absorb UMX patterns, provide `NativePtr<'T, 'region, 'access>`
3. **Farscape**: Fix CppParser to actually parse CMSIS headers
4. **Farscape**: Generate Fidelity-compatible output using fsnative + BAREWire types
5. **Firefly/Alex**: Add ARM bare-metal bindings for peripheral access

## Recommended Implementation Order

### Phase 1: BAREWire Foundation (Immediate)

Add to BAREWire (`src/Core/Hardware/`):

```fsharp
// Hardware.fs - Core descriptor types
module BAREWire.Hardware

type AccessKind = ReadOnly | WriteOnly | ReadWrite

type MemoryRegionKind =
    | Flash | SRAM | Peripheral | SystemControl | DMA | CCM

type BitFieldDescriptor = {
    Name: string
    Position: int
    Width: int
    Access: AccessKind
}

type FieldDescriptor = {
    Name: string
    Offset: int
    Type: RegisterType
    Access: AccessKind
    BitFields: BitFieldDescriptor list option
    Documentation: string option
}

type PeripheralLayout = {
    Size: int
    Alignment: int
    Fields: FieldDescriptor list
}

type PeripheralDescriptor = {
    Name: string
    Instances: Map<string, unativeint>
    Layout: PeripheralLayout
    MemoryRegion: MemoryRegionKind
}
```

### Phase 2: fsnative Types (Parallel with Phase 1)

Add to fsnative (`src/Compiler/Checking/`):

```fsharp
// MemoryMeasures.fs
[<Measure>] type peripheral
[<Measure>] type sram
[<Measure>] type flash
[<Measure>] type stack

[<Measure>] type readOnly
[<Measure>] type writeOnly
[<Measure>] type readWrite

// NativeTypes.fs
[<MeasureAnnotatedAbbreviation>]
type NativePtr<'T, [<Measure>] 'region, [<Measure>] 'access> = nativeptr<'T>
```

### Phase 3: Farscape Integration (After Phases 1-2)

Update Farscape to:
1. Reference BAREWire for descriptor types
2. Reference fsnative types for generated bindings
3. Generate `PeripheralDescriptor` instances from CMSIS headers
4. Output type-safe F# bindings using `NativePtr<'T, 'region, 'access>`

### Phase 4: Firefly/Alex Consumption (After Phase 3)

Alex bindings consume the descriptor information:
- PSG captures `PeripheralDescriptor` references
- Alex generates volatile load/store for peripheral access
- Access kind violations become compile-time errors

## The Unified Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Complete Pipeline Flow                           │
│                                                                         │
│  CMSIS-SVD / C Headers                                                  │
│         │                                                               │
│         ▼                                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Farscape                                                        │   │
│  │  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐        │   │
│  │  │ CppParser   │────▶│ TypeMapper  │────▶│ CodeGen     │        │   │
│  │  │ (clang AST) │     │ (C→F#)      │     │ (output)    │        │   │
│  │  └─────────────┘     └─────────────┘     └─────────────┘        │   │
│  │         │                   │                   │                │   │
│  │         │                   ▼                   ▼                │   │
│  │         │           Uses fsnative       Uses BAREWire            │   │
│  │         │           NativePtr types     Descriptor types         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                │                                        │
│         ┌──────────────────────┼──────────────────────┐                 │
│         ▼                      ▼                      ▼                 │
│  ┌─────────────┐       ┌─────────────┐       ┌─────────────┐           │
│  │ Types.fs    │       │ Bindings.fs │       │ Descriptors │           │
│  │ (F# structs)│       │ (externs)   │       │ (BAREWire)  │           │
│  └─────────────┘       └─────────────┘       └─────────────┘           │
│         │                      │                      │                 │
│         └──────────────────────┼──────────────────────┘                 │
│                                ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Firefly                                                         │   │
│  │  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐        │   │
│  │  │ PSG         │────▶│ Nanopasses  │────▶│ Alex        │        │   │
│  │  │ (w/ types)  │     │ (enrichment)│     │ (MLIR gen)  │        │   │
│  │  └─────────────┘     └─────────────┘     └─────────────┘        │   │
│  │                                                 │                │   │
│  │                     Descriptor info guides      │                │   │
│  │                     volatile semantics ─────────┘                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                │                                        │
│                                ▼                                        │
│                         Native Binary                                   │
│                    (correct peripheral access)                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## Verification Criteria

### fsnative Types Work

```fsharp
// This should compile
let ptr: NativePtr<uint32, peripheral, readWrite> = ...

// This should fail with FS8001
let value = NativePtr.read writeOnlyPtr  // Error: Cannot read write-only pointer

// This should fail with FS8002
NativePtr.write readOnlyPtr 0u  // Error: Cannot write read-only pointer

// This should fail with FS8003
let mismatch: NativePtr<uint32, sram, readWrite> = peripheralPtr  // Error: Region mismatch
```

### Farscape Generates Correct Types

```fsharp
// From CMSIS: __IO uint32_t ODR
// Farscape generates:
ODR: NativePtr<uint32, peripheral, readWrite>

// From CMSIS: __I uint32_t IDR
// Farscape generates:
IDR: NativePtr<uint32, peripheral, readOnly>

// From CMSIS: __O uint32_t BSRR
// Farscape generates:
BSRR: NativePtr<uint32, peripheral, writeOnly>
```

### BAREWire Descriptors Are Complete

```fsharp
// Farscape can populate:
let gpioDescriptor = {
    Name = "GPIO"
    Instances = Map.ofList [
        "GPIOA", 0x48000000un
        "GPIOB", 0x48000400un
        // ...
    ]
    Layout = {
        Size = 0x400
        Alignment = 4
        Fields = [
            { Name = "MODER"; Offset = 0x00; Type = U32; Access = ReadWrite; ... }
            { Name = "IDR"; Offset = 0x10; Type = U32; Access = ReadOnly; ... }
            { Name = "ODR"; Offset = 0x14; Type = U32; Access = ReadWrite; ... }
            { Name = "BSRR"; Offset = 0x18; Type = U32; Access = WriteOnly; ... }
        ]
    }
    MemoryRegion = Peripheral
}
```

## Conclusion

The fsnative → Farscape → BAREWire dependency chain is **mission critical** for hardware targets. The components must advance in lockstep:

1. **BAREWire** provides descriptor types
2. **fsnative** provides pointer types with measures
3. **Farscape** uses both to generate complete bindings
4. **Firefly/Alex** consumes the result

Any component falling behind blocks the entire chain. The January demo specifically requires all four components to reach minimum viable capability.

## Related Documents

| Document | Location |
|----------|----------|
| Staged Memory Model | `/docs/Staged_Memory_Model.md` |
| Farscape Maturation Plan | `/docs/archive/Farscape_Assessment_January_Demo.md` |
| FNCS Ecosystem | `/docs/FNCS_Ecosystem.md` |
| UMX Integration Plan | `~/repos/FSharp.UMX/docs/fidelity/UMX_Integration_Plan.md` |
| BAREWire Hardware Descriptors | `~/repos/BAREWire/docs/08 Hardware Descriptors.md` |
| Farscape Architecture | `~/repos/Farscape/docs/01_Architecture_Overview.md` |
| Farscape-BAREWire Integration | `~/repos/Farscape/docs/02_BAREWire_Integration.md` |
| Farscape-fsnative Integration | `~/repos/Farscape/docs/03_fsnative_Integration.md` |
