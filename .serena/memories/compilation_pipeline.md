# Compilation Pipeline (Updated January 2026)

## Architecture Change: FNCS Builds PSG

> **CRITICAL**: FNCS now builds the PSG. Firefly consumes it as "correct by construction".

## Overview

The compilation pipeline flows through these major phases:

```
F# Source → FNCS → PSG (with native types, SRTP resolved) → Firefly → MLIR → LLVM → Native Binary
```

## Pipeline Stages

### 1. F# Source
- User-written F# code
- Uses Alloy library for runtime-free implementations
- Project configured via `.fidproj` TOML files

### 2. FNCS (F# Native Compiler Services) - BUILDS PSG
- **Location**: `~/repos/fsnative/src/Compiler/`
- **Purpose**: Parse, type check with native types, build PSG
- **Key Point**: FNCS produces the PSG, not Firefly

**What FNCS Does:**
- Parse F# source (SynExpr, SynModule)
- Type check with native type universe (no BCL)
- SRTP resolution during type checking
- PSG construction with types attached
- Preserve symbol info for design-time tooling

**What FNCS Outputs:**
- `SemanticGraph` with native types attached
- SRTP already resolved (no post-hoc resolution needed)
- Full symbol information for editor services
- Only reachable nodes (after analysis)

### 3. Firefly (Consumes PSG)
- **Location**: `/src/`
- **Purpose**: Consume PSG from FNCS, apply lowering passes, generate code
- **Key Point**: Trusts PSG as "correct by construction"

**Lowering Nanopasses (if needed):**
- FlattenApplications
- ReducePipeOperators
- DetectPlatformBindings
- etc.

### 4. Alex/Zipper
- **Location**: `/src/Alex/`
- **Purpose**: Multi-dimensional hardware targeting layer
- **Components**:
  - **Zipper** (`Traversal/`): The traversal engine - provides "attention"
  - **XParsec**: Pattern matching combinators for PSG structures
  - **Bindings**: Platform-aware MLIR generation

### 5. MLIR
- **Purpose**: Multi-Level Intermediate Representation
- **Key Point**: Progressive lowering through dialects
- **Generated by**: Alex Bindings based on PSG traversal

### 6. LLVM (via Toolchain)
- **Purpose**: Low-level code generation
- **Output**: Native machine code

### 7. Native Binary
- **Output Types**:
  - `freestanding` - No runtime dependencies
  - `console` - Minimal libc dependency
- **Key Point**: "Compiles" means a working native binary that executes correctly

## What Changed from Old Architecture

| Old Architecture | New Architecture |
|-----------------|------------------|
| FCS parses & type-checks | FNCS parses, type-checks, builds PSG |
| Firefly builds PSG from FCS output | Firefly receives PSG from FNCS |
| Baker correlates typed tree with PSG | No Baker needed - FNCS attaches types during construction |
| SRTP resolved in nanopass | SRTP resolved during type checking in FNCS |
| Multiple tree correlation | Single unified representation |

## Components Moving FROM Firefly TO FNCS

With FNCS handling PSG construction, these components are ABSORBED into FNCS (not deprecated - the functionality persists):

| Firefly Component | Absorbed Into FNCS As |
|-------------------|----------------------|
| `src/Core/FCS/` | FNCS replaces FCS integration |
| `src/Baker/` | Type correlation during PSG construction |
| `src/Core/PSG/Builder/` | PSG construction in FNCS |
| `Nanopass/ResolveSRTP.fs` | SRTP resolution during type checking |

**Key insight**: Baker's work (type correlation, SRTP resolution, typed tree overlay) is ESSENTIAL. It doesn't disappear - it moves into FNCS and happens during construction rather than as a post-hoc phase.

## The Fidelity Preservation

The PSG is not merely an AST - it is a **semantic graph carrying proofs** about:
- Memory lifetimes
- Type safety
- Resource ownership
- Coeffects

FNCS attaches all type information during construction. Alex consumes this rich semantic information to generate MLIR that preserves all guarantees.

## Key Constraint

> **"Compiles" means a working native binary that executes correctly, not just successful parsing or IR generation.**

Every change must be validated end-to-end with a working binary.
